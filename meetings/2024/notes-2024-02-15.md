# 15 February 2024 | MessageFormat Working Virtual Face-to-Face

### Attendees
- Addison Phillips - Unicode (APP) - chair
- Eemeli Aro - Mozilla (EAO)
- Elango Cheran - Google (ECH)
- Mark Davis - Google (MED)
- Mihai Niță - Google (MIH)
- Richard Gibson - OpenJSF (RGN)
- Shane Carr - Google (SFC)
- Staś Małolepszy - Google (STA)
- Tim Chevalier - Igalia (TIM)
- Ujjwal Sharma - Igalia (USA)
- Zibi Braniecki - Amazon (ZBI)


Scribe: EAO, ECH, TIM, USA

## Topic: Action Item Review
https://github.com/unicode-org/message-format-wg/issues?q=is%3Aissue+is%3Aopen+label%3AAction-Item

## Topic: Progressing to Done

The main blockers appear to be the following:
- ~~Beautification of the syntax discussion~~
- ~~What’s in a name? (Does NCName fix our woes? Go to UAX31? what?)~~
- ~~Quoting~~
- ~~Format-to-Parts~~
- ~~Spannables~~
- ~~Expression Attributes~~
- Registry and default functions
- Implementation and testing


Schedule:
1. No new LDML45 issues after 15 January.
2. All LDML45 issues resolved by end of F2F. Balloting alpha spec to occur 15 February.
3. Beta spec and registry by 11 March.
4. Can make limited changes thereafter, for issues discovered by implementers.
5. Release 10 April as part of LDML45

## Topic: PR Review
Timeboxed review of items ready for merge.

| PR   | Description                                              | Recommendation                                                            |
|------|----------------------------------------------------------|---------------------------------------------------------------------------|
| #649 | Add options to close                                     | Review syntax details. Merge                                              |
| #648 | Implement changes to date/time functions                 | Merge                                                                     |
| #647 | Add tech preview attribute recommendation                | Review text. Merge                                                        |
| #646 | Update spec as if PR #645 were accepted                  | Discuss                                                                   |
| #645 | Add design doc for dataflow composability (#515)         | Discuss.                                                                  |
| #644 | Clarify the data model introduction                      | Merge                                                                     |
| #643 | Add data model stability policy                          | Merge                                                                     |
| #634 | Design doc to capture registry maintenance               | Needs work. Discuss approach.                                             |
| #633 | Make arrays in the data model not options                | Merge. Incorporates discussion.                                           |
| #632 | Remove expression attributes from the data model         | Reject. Goes against data model design principle.                         |
| #630 | Address #629: create invalid expression error            | Merge                                                                     |
| #625 | Remove non-registry functions and options from examples. | Review for changes due to #648, #621. Discuss detail with @eemeli. Merge. |
| #621 | Describe number selection fully                          | Merge                                                                     |
| #620 | Make declarations array optional in data model           | Merge or reject.                                                          |
| #584 | Add new terms to glossary                                | Future                                                                    |
| #570 | Add :date and :time functions                            | Modify to match #648                                                      |
| #558 | Add <when> to help select the right <match>              | Future                                                                    |


#647

EAO: Want to reserve space for the WG to discuss the still-open expression attributes.

APP: We should not fragment the space pre-emptively

STA: Prefer APP’s wording

APP, STA: Leaving out options for translation only should not be discouraged.

APP: Will add a suggestion, merging later.

#630

all: ok with merge

#625

EAO: Still waiting for input from others.

#620

APP: Obsoleted by #633

#570

EAO: Will update once the design doc has been approved.
## Topic: Issue review

Let’s close all of the issues
https://github.com/unicode-org/message-format-wg/issues?q=is%3Aissue+is%3Aopen+label%3ALDML45


## Topic: Syntax Change Review (#649)

Thanks to Mihai for putting the last syntax changes in. Merging the changes.

all: ok with merge

STA: Happy that all comments left open on #347 have been resolved.

## Topic: Data Model (#644, #643, #633, #632, #582)

We agreed to handle data model in some specific ways on Monday/Tuesday. Let’s review the PRs and agree if we have met our goals.

all: ok with merging #644

#643

STA: Concerned with data model compatibility with stability policy

USA: Data model stability should be enforced by conformance testing.

APP: This is the stability we’re promising on the data model. And we should have tests for the data model.

STA, EAO: Ok with merging provided that unsupported-annotation is fixed as discussed.

#633

STA: Will resolve the merge conflict.

APP: Will merge afterwards.

APP: Merged.

#632

STA: Like that data model is supporting round-tripping, but still concerned about introducing “attributes” in the data model.

APP: Syntax defines attributes rather specifically, as mentioned by EAO. The spec says they have no meaning.

STA: Concerned that it’ll be used before it’s ready. Would prefer it to contain garbage. Not looking to change the syntax

EAO: I want to get this thing done, and don’t think “attributes” is particularly risky. But if STA insists, I won’t object to garbage.

MIH: We’re not promising stability, so people should be ok with needing to adjust to changes here.

STA: 1) Would be more comfortable with garbage, 2) Technically we’re not promising stability, so could remove attributes later.

APP: We should still act as if the stability policy already applied. The syntax here is specific, and the data model should reflect that.

MIH: Looks fine as it is, concerned about what happens with this later. If we later remove attributes, should be able to remove them from the syntax & data model as well.

EAO: Keep them in now, but resolve the issue within the tech preview.

STA: I’m ok with that.

APP: Closing the PR unmerged, will remove expressions attributes separately from stability policy.

EAO: The changes proposed by Mihai feel like a lot to take in right now, particularly that they’re changing a lot of the data model and this is coming relatively late. Not coming in w/ discussion on why these changes are being asked for and why they’re better than the previous structure. One particular thing I noticed is that currently, the data model at the top level recognizes that we have two different sorts of messages. One w/ a single pattern, one w/ multiple patterns and a matcher. It specifically does not differentiate the simple vs. complex sort of split that we have in the syntax. In the data model, we don’t need it. Complex single-pattern looks a lot like simple. Introducing this split into the data model would create challenges. For when you want to verify that something works as a simple message, or needs the double braces b/c it starts with a period. The proposed changes make it harder to do certain data model operations and make the data model more aligned with the syntax without explaining why. 

MIH: I hear you and I’m happy to revert that part. Do we try to solve this entirely in this meeting now? I don’t feel prepared for that. I mostly had renaming things; I didn’t change the structure in a big way, with some exceptions, like that one. The other exception is markup – unified them into one thing, not 3 different types. Consistent with feedback I got before. I’d propose to continue this on the PR. If that’s the biggest concern, I can totally revert it. Probably the other structural one – maybe it would have helped to do a pass of renaming things for consistency with the syntax and then another restructuring pass. The other one was something like “unsupported foo” and I split it into reserved and private-use.

APP: Private-use is not unsupported

MIH: Yes, but before my changes, we had one big bucket called “unsupported expression”, and I split it in two. The proposal is: are you OK to continue this on the PR or do you want to solve it now?

APP: I think we should not fix the data model by talking about it as a large group. Sounds to me like you and Eemeli should spend some time making sure you’re on the same page wrt design and goals. There’s some gold nuggets in the stuff you’ve done and maybe some things that need to be ironed out. If you collaborate on that and fix this PR or make a new one, we should come back offline from this later. I’m leery about hacking at the data model with ten people.

STA: I just realized that now that we’ve defined the data model goals a bit better with the intro PR, and one of them is to be able to re-serialize back to an equivalent message – for one thing, whitespace, for another, quoted/unquoted literals, quoted/unquoted simple patterns.

APP: equivalent – serializer can add quotes

STA: so equivalent makes no guarantees about whitespace and no guarantees about spelling of quotes – serializer can see a value of an option and choose whether to quote or not. Could be problematic for some workflows. They could do their own data model, though

EAO: My preference is for Mihai and I to have a dialogue about the issues you see with the current structure of the data model. We can talk about why the data model has unsupported annotations/statements rather than reserved and private ones. Not topics for this meeting, but I think it would help for us to have the dialogue first about what the structure should be where there are differences between data model and syntax. Once we resolve those core issues, we can decide on changes.

MIH: I’ll summarize and share with everybody what I think. Do we want to try to bring the naming closer to the syntax where possible? I think it’s useful when syntax is closer to the data model, at least wrt names. I’ll create issues.

APP: I would suggest you use a high-bandwidth medium like a call, or Slack with each other a bit, just to ensure that you aren’t talking past each other, at least initially. J

TIM: Regarding normalization, it would be good to write down some syntactic rules. Ex: replace messages with surrounding whitespace with quoted patterns. This makes it clear how implementations should do re-serialization so that there is not ambiguity.

EAO: I have written at least one CST (concrete syntax tree) implementation for MF2 b/c the data model does not encode all information for getting out the exact same characters. Addison, do you have a deadline for us to resolve stuff around the data model?

APP: Soon. It would be good if it happened this week; by Wednesday Feb. 21?

EAO: We need to set up something for your Wednesday morning as I’ll be OOO

MIH: I can’t create issues today, so don’t expect any new issues until your tomorrow. I have the day off on Monday but can work on this if necessary.

APP: I suspect I’m going to communicate to Mark that I’m going to use his later date for CLDR to get the results of our work. I think the data model has to be there. It’s taking us some time. I still hope to be done with a bunch of stuff here in this call. When we talk about testing/etc., that will be draggy. 
## Topic: Number, Date (#648, #621, #408)
Timeboxed discussion of number and date formatting to approve the changes discussed yesterday. Discussion will be limited to whether the changes have met the consensus. 

APP: Yesterday tentatively agreed on :date & :time, the latter of which has a couple of options to discuss: hourCycle and timezoneName.

EAO: My sense of the hourCycle is that this is, like with the other stuff we ended up kicking out, definable by a locale. So effectively if we kick out most of the things that are definable by a locale, we should kick out all of them and address them later.

MIH: The reason for hourCycle is that we have four values: h11, 12, 23, and 24. h12 and h24 sounds a lot like booleans, which is just glassing over the fact that that’s not it. When people say I want 24-hour they mean they want 23-hour. I think having boolean flags would be a bit confusing. I know in reality there’s no locale that uses h11 and h23…

USA: I believe there’s one that uses h24 but I would need to check.

APP: The thing is to give people the features they need when writing messages so they can get their work done. To Eemeli’s point, it makes sense to not provide all the options in the universe. We agreed tentatively not to provide the option bag skeleton thing for :date and :time. I think there are specific things people want to override on date or time values. It’s a common thing to do. For time, I think they want to set the time zone and want to switch the hour cycle between 12 and 24, without decorating the locale. An option to do that would make sense. The hourCycle option may not be the tool to do that. They want to let the locale decide on the hour cycle. 

MIH: the trouble is, usually the locale doesn’t have an opinion.

APP: restore time zone, get rid of time zone name, provide an hour12 flag to let people switch between 12 and 24

MED: I agree people need this. Many implementations let people set the hour cycle as a user pref. In CLDR we have a set of preferred hour cycle patterns and those hour cycle patterns let you choose a pattern. It’s presumed that the choice comes in from user preferences. There’s a default for the locale; certainly don’t want to decorate locales with all sorts of weird options. Systems aren’t built for that. I would propose having at least hour12 and hour24; then people can use that to override the locale. If we want to give people more control we can have h11, 12, 23, 24. I agree we don’t need that going out of the chute.

MIH: From what I know, we don’t have datetime in CLDR or ICU APIs to tell us, if I wanted a small-hour type of thing with 8 PM, to say if it’s h11 or 12. We have something like that for the locale. But if I override it and say I am in the US and I want 24. There’s no info to tell us if it means 23 or 24.

MED: There is in CLDR and I think it leaks over into ICU (not sure)

MIH: I’ll take a look

APP: I’d like to hear feedback on pulling time zone back and then get a sense for the hour cycle thing and if there’s any objection to taking it out

EAO: My preference is to take the hour cycle and time zone name options back out of time. I think that’s closest to the consensus we achieved yesterday. We discussed taking out everything but the style and then we tossed in all the calendar stuff, etc. This feels like we’re not fully in alignment, as to what the shape of this option is. Similarly to how we’ve left the detailed stuff out from date and time, we should take the time to discuss exactly how to have hour12 or hourCycle as the option for that, the time zone name also feels a lot like the options that are specific to the skeleton-y sort of solution, which might end up looking different or might end up looking like what we have currently. Could decide to decide about this later, as we’ve done for most things except that we have :date and :time with a style option.

APP: I already proposed we drop time zone name to the future bucket, and I’ll make that change. There’s a use case for hourCycle but we could drop it. Things to watch, along with calendar and numbering system. Time zone feels – I did a lot of stuff with time zones in formatters. That feels like something that if we don’t provide an option, people have to do goofy things. Or they have to set it at the message level in the formatting context, which is something we don’t specify, but implementation guidance. I’m looking for guidance for us to lock this down. 

MED: I’m OK as long as this is an option on :datetime. I’m viewing date and time as limited… people will end up, if what they want to do now is check it out during tech preview… I think it’s vital we have a full set of capabilities in tech preview or people won’t try it out. But as long as it’s in :datetime, cool. If you want to drop everything from :time I don’t care.

APP: Do we have agreement on dropping hourCycle and time zone name from time, and time is just an option list thing for default time formatting?

EAO: It still has style, right?

APP: Yes, but no field options. No objections? [none] That’s easy, I can just merge Eemeli’s suggestion. Any appetite to put time zone back?

MED: Time zone is in :datetime, right?

APP: No; these are not part of the default registry but we’re working on them.

MED: As long as people can use them in tech preview, even if they have a funny status. We need to make it clear that they can use it in tech preview, it’s not completely defined but they can use it to verify that everything works for them.

EAO: I suggest that you, Mark, might have some pull in making sure ICU’s impl includes it. The JS polyfill will delegate all of this to Intl.NumberFormat and Intl.DateTimeFormat. Those impls will support this for experimentation during tech preview, even if it’s not in the default registry.

APP: Is the rest of this ready? Any objections to date and time functions? [none] All right, closed.

APP: Should we talk about numbers? That is PR #621. Shane and I did a lot of back and forth and I think have resolved most of the things. One of them is that compact display now depends on notation compact, otherwise the option is invalid. That’s only described as text, obviously, since we’ll have to figure out how to do it in registry-land later. Other things: I added notes to describe the min-max things b/c they don’t have defaults b/c they’re overrides. I think that covers most everything. Shane is uncomfortable with our use of the term “resolved value”, so there’s some discussion there. I don’t think that’s material to the set of options and operands and whatnot.

EAO: Shane left a comment half an hour ago saying this PR was acceptable to him, though he would like to clarify the contents of the resolved value for literal selection. Sounds like a small follow-on PR. 

APP: I’m still thanking you for giving me writing number selection. This spec includes a section on determining exact literal match. Previously, this section tried to describe exact literal match for any number, including fractions, significant digits, all of that, through hand-waving + examples. I kept the examples in the doc but the text now says both normatively and in a big note, “only integer matching is required in the tech preview; feedback would be helpful, otherwise users should avoid using matching… the following examples show selector keys that have fractions and/or sig digits.” We would not be supporting that in tech preview, but implementations could try to figure it out. I think it’s a super rare use case, can’t recall where an exact match would work. I have examples of where I’ve used choice format to say “numbers between a certain range get one style vs. another”. This is not that, b/c you can’t exact match them. Are we good with that?

MED: Just one minor change: it says “otherwise users should avoid using matching, such as in the following examples…” I’d say “matching fractions”, just to be clear

APP: I’ll change that

EAO: Do you want me to modify my suggested change for that?

APP: Why don’t you do that, and I can merge it in. Then we’ll be done with numbers. I have the followup work… changing things to :number

EAO: is the appropriate phrase “users should avoid using matching with fractional numbers”

APP: Or sig. digits?

EAO: Or sig. digits. Comment updated.

APP: So I can merge this? Last chance for objections [none]

MED: need to fast-track removal of “Otherwise, users should avoid using matching with fractional numbers or significant digits.” later.
## Topic: Registry Maintenance
Includes whether to reserve all single-letter namespaces
https://github.com/unicode-org/message-format-wg/pull/634 

APP: I created an embryonic design doc for us to discuss how to manage the registry going forward. My general thinking: we have a default registry, every impl is required to implement everything in the default registry to claim conformance. So we’ll need to be conservative about what we put in there. We’ve been super conservative this week. I think it’s appropriate. We want to avoid requiring particularly small impls from having to implement things with large-scale requirements. The awk version of MF2 shouldn’t be required to implement PersonNameFormat. One level of maturity, and it’ll have a reasonably high bar for inclusion. But a bunch of things ought to be standardized and should be generally portable between impls that support it. So I propose we have a separate level of maturity that I called “RGI”, which is “Recommended for General Implementation.” Which is to say that if you’re creating a person name formatter, the function should be called this and have these options with these values. We don’t say how it works, but it’s a standardized set of functions or options for existing functions that we recommend that impls use instead of other things, such that finger knowledge of MF2 message writing is portable and it’s just that some messages don’t work on impls that don’t support that specific feature. This, for example, would be where we would incubate some of the options we just kicked downstairs for numbers/dates. Thinking about it, RGI is actually the endpoint of a process of incubation. We will need to create stages. Not this week, but we’ll need to think about – we kicked calendar as an option for datetime out of the default registry. The proposal to add calendar to either the default registry or RGI should be – there’s a design doc, and acceptance, and experimentation, and then we say this is ready. Either in the default registry or RGI. The third bucket is reserving ourselves a namespace for things we think are maybe not “everyone should do this”, but specific kinds of things that are templates for people to use. Maybe ICU skeletons as an example; we don’t tell everyone to use it, but if you were to do that, it would look like this. Would also be a place for people to contribute not general-interchange but other kinds of useful patterns that e.g. play nice with CLDR data. That’s the outline. Post-45, we’ll need to flesh this out. In the short term, we have a bunch of things that go into developing towards RGI that we’ll need to think about how to store.

MED: I’m kind of interpreting the RGI as “these are optional, but if you do use them, you use them with the meaning that is associated with them in the RGI repo.” That is, we wouldn’t expect to implement this in a different way and call it the same name. Is that right?

APP: That’s the intention

MED: And then the third bucket is reserving a namespace for – my question is what sort of stability would we attach to that. A fourth bucket could be if we reserve a namespace for – this is really private-use, and I’m going to try some stuff out internally before I surface it, that way it doesn’t collide with anything that happens when I refresh my repo with the standard one and I get a collision. I could see having something like an x: for “this is just purely internal stuff that I want to make sure doesn’t collide with the external world.” Until we get some notion of what namespaces look like and how to register them, and so on.

APP: We know what they look like; don’t know how they work or play together

MED: How would Apple say “I have the namespace apple:” or whatever?

APP: You pick a valid namespace identifier string. We talked about whether to make this formal, registered, etc. Fact is that plugin function sets are not portable, plug into a specific impl in a specific PL. Can’t take a Java one and plug it into your C impl. We also talked about tools wanting to get a URL to read the registry because it tells you things about the functions and their options and meanings. We would want to create that kind of landscape, whether people build an ecosystem of plugin libraries or not, we’ll find out. The intention is for that to be possible.

MIH: I was wondering if we can let it be a little bit free-for-all. If you look at C++ namespaces or Java packages, it’s like, you can do com.google.something but there’s no central place to register it. If you do com.google or com.apple or whatever, you’re probably safe unless you want to publish in Maven Central and that becomes the gatekeeper. I could write com.ibm myself but not put it in Maven Central. But the Java standard doesn’t stop me from doing things.

USA: My understanding is that there might not be a singular centralized online registry for sharing these around, but given the plug-and-play nature of these formatters/selectors, I believe people will do that. They would name them as they want and there might be a place that enforces unique naming, but that’s it.

EAO: Two things: first, for stuff that is ending up in the anonymous top-level namespace, I think establishing an explicit stability attached to the things there would be good. Something like alpha, beta, stable, leading to RGI. Keeping the same names, not having namespaces that things move in and out of. The history of the x namespace in CSS is somewhat messy and – I don’t think we particularly benefit from that, as long as there’s a way to communicate that this thing :person is at an alpha level, and your implementation might support it but its meaning could change or it could be removed. Second, as a new idea, following from expression attributes, I think we should reserve the u namespace so we can discuss later if we want to define u:locale as an option to have some very specific meaning that can be used on a number of different functions. Having a namespace would be beneficial there, esp. for the options. People will write their own functions and if we want to define a default thing in the options of a custom function, we need a namespace. u: seems like a decent choice. If we reserve it for options, we should have it for functions as well. I don’t know what we’d want to put there, but we would have it.

APP: Wild enthusiastic support via reacts. Extremely valid use for u namespace – avoids us creating a new option that steps on everyone’s custom implementation. Makes a lot of sense to me. We should add that. The anonymous namespace, I think, is the thing we own. We should encourage people to use namespacing for their own stuff, and people will want to make that super easy. Google’s namespace will probably be called g for custom inhouse functions. No one wants to type “goog” or “google”, etc. every time they use a function. Sort of self-solving. STA and I had a conversation in Seville about assigning a namespace within the implementation, and the URL to the registry could get associated with some prefix so it’s tailorable. This is not necessary for us to deliver, I just want us to think about it.

MED: I had a different idea of what namespace was supposed to be. It sounds like the idea of this group is that they’re used to not collide with the standard functions and options. But I don’t care about collisions between Google and Gentech, and both of them using g:. So we’re saying the namespaces are sort of free-form and any collisions are just accidental and we’ll “let the market decide”?

USA: I was curious on the topic of namespaced options to custom functions: does it imply that if you used a namespaced function like u:locale, it would be processed by the implementation before passing it into the custom function?

EAO: We would need to discuss this. Other thought: one reason I like the RGI is – we can think about the dynamics of adoption and people who get interested in localization and message formatting. We are from their POV delivering MF2 as a semi-ready thing. Someone who gets really into this – the RGI gives us the opportunity to give them a venue in which they can improve the project. Later, not this week, we should come up with a mechanism for people to propose new function definitions for the top-level anonymous namespace. Not stuff that is by default on everyone, but have a way to come together to discuss what e.g. :list looks like. So the interface for these things, as with the default registry, gets agreed upon, and the ecosystem gets richer. Provide the right basis for constructive discussions around this that hopefully will help the meta-level propagation of MF2. 

STA: One clarification: I don’t remember and can’t find in the doc, when we have a namespaced custom function, do all of its options need to be namespaced as well?

APP: No

STA: So they’re namespaced by the fact of being –

APP: The purpose of namespacing an option is to modify a function in a different namespace, e.g. the anonymous one. So :datetime might have icu:skeleton

STA: APP said we own the anonymous namespace – should qualify that by saying we own the function names in it, not option names.

APP: A function owns its options; if you want to extend, you need to namespace that, because we might want to assign one later.

MED: Suppose I have a namespaced option – then I’m presuming I just define whatever values that namespaced option has. The function is :datetime, the option is mark:minFractionDigits. Then I define what the options are. Do we also have namespaced option values?

APP: No, because the syntax doesn’t permit it; they would look like strings

MED: We might have that conceptual picture clear for people in the documentation of namespaces. What STA just said – anytime anyone in this group asks a question, 1000 other people will be thinking it and not see it in the spec. We should capture these sorts of questions people have, add an FAQ, etc.

STA: There is a design doc, but I didn’t notice. I think that’s a good comment.

EAO: The u namespace must be reserved.
## Topic: Dataflow composability (#645)
Let’s discuss Tim’s proposal.

TIM: The motivation is to ask what happens when you bind the result of a formatter to a name and is formatted again. I thought it was useful to introduce names for some things that are currently all collapsed under ResultValue. The spec says that the formatter returns a raw value (Formattable) or it can return a formatted value. If it’s the latter, it has to return that together with some information about how it was constructed. You can’t just format the string and lose all the options. The main question is: how normative should it be? This could be broken up into (a) an editorial change that just renames stuff, and (b) the actual dataflow part where we say, you cannot just return a formatted value without context.

APP: Thanks for working on this. Some of these things are scary because of the transitivity of things is purely in the eyes of the beholder. We do expect declarations to decorate calls or perhaps to refer to an expression that returns something later.

MED: My mental model here is that there’s two kinds of options: one kind fundamentally changes the value of what your operand was. This happens for offset or selection. But most of the options don’t change the value, they just change what the formatter would produce. 

TIM: The way I’ve written the PR is that all options should be preserved. However, it could be adjusted so that functions get to choose which options to emit so they can decide which options get consumed and which carry over.

EAO: Main question is, is there anything in the current spec language prohibiting anything that your proposed text will be allowed. I’m looking whether there’s space for us to reconsider this later.

TIM: I would need to go over the spec to figure out what’s editorial and what isn’t. There might be a couple of normative changes there but I’m not entirely sure where.

STA: I second Eemeli, it’s a good feature which is hard to implement because … for transitivity, there can be different models. Tim suggested a tree model but at least we could require implementations to provide a flat structure that goes one level deep. Like how C++ copy constructors do. Just this however would be a massive opportunity for more grammatically complex languages.

APP: The thing we need right now is: does our spec prevent something that’s impossible to do later. Guidance to implementations like this aren’t entirely normative and can be communicated at a later stage. That’s the key thing. For me in userland, when you write a message does the annotation transmit or not is really important, and for portability it’ll be important to be consistent. Maybe we should specify which operations are transitive and which aren’t.

ECH: I second Tim, this is an important thing to think about. We should be giving this guidance, normative or not. We could also do it later. ICU4J has FormattedValue as an interface. Also ECMA-402 APIs lean in this direction.

EAO: One of the biggest parts of the preview period is implementer feedback. It is entirely within our scope to consider all the normative changes later since this is quite literally implementer feedback.

MED: I don’t think we want to have a model that ends up requiring a tree structure. When I’m looking at the first example in Tim’s document, if they’re not equivalent, the result would be different. In that sense I’d qualify this as normative. In the case of offset, I am modifying the internal value and some interesting things may happen when I use local to redefine a modified value. We need to figure out if we’re dealing with the modified value or the base value before we finalize anything.

APP: Since it’s a design doc, I’d rather we merge it and iterate. I’d need to figure out the details, so I’ll go through it later. Another thing I’d call out is: what’s the testable surface of this? If we can get that, I’m less concerned about the internals. How do we describe what’s actually happening.

EAO: Mark’s comment about multiple by 10 reminded me that while we don’t have a multiple by 10 function, we have a divide by 100 function basically via percentage.

TIM: To your last point, I was just thinking about that. To make the normative parts of this normative, we’d need to write tests but we can probably single out some tests and expose them on the design doc. That would justify putting some instructions somewhere. This is almost like a datamodel for the runtime values.

APP: Let’s merge this and comment from there, the important part would be to see if there’s something here that harms the current spec, but I think there’s nothing

MED: We need to nail down these things before release but for now there’s nothing harmful.

EAO: It might be easier to discuss certain parts of the doc if we keep the PR open, since we can make per-line comments.

## Implementations and Testing
Let’s review implementation progress and how to ensure that all normative requirements have tests. Let’s make a plan for building out the tests.

EAO: The JS stuff has not been updated for any changes from this week and it passes the test suite. I made a PR with a second parser which caught some bugs. Looking good overall.

MIH: The Java one is a bit problematic. The parser works just fine. We have documents presented today that describe how things should work so that’s my biggest concern right now. I’ll have to pull all-nighters or even work weekends to make sure it’ll be in the next ICU release but I can’t promise it.

MED: I’ve been pushing people in CLDR to raise issues here. I don’t expect any substantive issues to come up in the CLDR meeting.

MIH: I hope for the same.

APP: Leaving aside last minute changes?

MIH: 95% confidence? I’m reluctant to say 100%. I’m confident that it’ll get in but it won’t perhaps match 100% of the spec. It’ll be a preview implementation and document “known issues”. The other thing is that I’m trying to make it ICU independent so that it can be backported to Android. In theory, it can be released outside ICU with ICU as a dependency. This way I could push updates faster.

TIM: I got feedback from the TC a few hours ago. I was asked to let the design doc sit for another week for comments. After that I can submit a PR for the code and from there it’s just a process of how long the review process goes.

EAO: Do these implementations target any other format than string?

MIH: Right now instead of formatToParts, it formats to a Formattable instance that can finally be formatted.

EAO: Is there a spec for this?

MIH: No, it’s just conventional ICU behavior.
Example for `NumberFormatter`:
https://unicode-org.github.io/icu-docs/apidoc/dev/icu4j/com/ibm/icu/number/FormattedNumber.html
`MessageFormatter` (previous tech preview of MF2):
[`MessageFormatter.format`](https://unicode-org.github.io/icu-docs/apidoc/dev/icu4j/com/ibm/icu/message2/MessageFormatter.html#format-java.util.Map-) produces a [`FormattedMessage`](https://unicode-org.github.io/icu-docs/apidoc/dev/icu4j/com/ibm/icu/message2/FormattedMessage.html)

TIM: As for ICU4C I’ve not done that. There’s an analogy in ICU4C but I set that aside for later but for now it only formats to a string.

MED: That should be enough for the tech preview.

MED: We have a place in CLDR for test data files. It’s used by implementations. That’s the best place to keep a directory for MF2 tests.

EAO: Technically we are compliant for what we’re supposed to deliver due to the JSON stuff. I agree that it’ll be helpful for implementers but that’s pretty much it. As I’m working on my own test suite, should I add it to the stuff we’ve got or should I wait?

APP: Add it soon so we can work on porting everything together.

ECH: We have the ICU4J implementation but it’s out of sync now so we’re waiting for the ICU4J implementation to come back in order to test. EAO should put in what he’s got so far.

EAO: One part there is that we’re aiming for a conformance test suite.

MED: There are two kinds of tests: some of them are hand developed nasty locales and then the expected result is true or false or the expected result is to test for normalization.

…

MED: We can have tests that say: if you follow CLDR, you get this result. But we keep it narrow because 

ECH: Versioned datasets is something we do on the Conformance suite. If conformance is to the normative parts of MF, how does testing look like?

MIH: I think what we can also do (something that was impossible earlier) would be to have custom formatter implementations for testing only. That’s how you can test the pipelines properly.

EAO: The data that I’ve provided for the tests that I’m using for my own implementation: these things are here to emit a syntax or data model error. Second is messages that work without any functions. The third lot is tests that do include the functions that we’ve defined and how they behave. I’m also using that data in three different ways.

MED: One way this can work is that we can basically provide data for a mock: so basically the operand and the options and this value can be in the test file. You get the stability Mihai was talking about; doesn’t depend on the version of CLDR.


## Spec Publication and Balloting
Let’s review how the spec will be prepared for inclusion in LDML. Let’s review the balloting plan.

APP: Take the material we have and paste the things we agreed to do today that are remaining action items; turning that into a final spec and balloting it for acceptance by the WG. I believe our target is to produce HTML either as a subsection of TR35 or –

MED: It’ll be a new part

APP: If I turn our spec into a long HTML file that we title appropriately –

MED: If you look at the source for the CLDR parts, we use GFM markup to produce the CLDR parts. So if you’re using markup, then you shouldn’t have to do much. – I mean Markdown. So you don’t have to produce an HTML file if the source is markup. I’ll send you an example of one of the parts.

Example doc:
https://raw.githubusercontent.com/unicode-org/cldr/main/docs/ldml/tr35-numbers.md 

APP: I’ll sync up with you offline and will produce the candidate; then I’ll produce a voting ballot for “this is ready for tech preview”. It’ll be a strict up or down vote. I will also prepare a doc about the things we’re seeking feedback on in preview, which I will circulate to the WG. One of my action items is to fill out the template for tech preview feedback; currently it just makes an issue with a specific label and title. I’ll fix that up. 

MED: Back to the document, I can walk you through it, but the TOC is generated automatically by a tool, so you don’t have to worry about that. The one other thing is we keep the links to the section headers stable. Markdown will generate an anchor for you but if you look at the example, you’ll also see little fragments of HTML to make it into an anchor; that’s to preserve compatibility with previous versions. 

## Topic: AOB?

EAO: Do we have the behavior of :string written anywhere? Or are we assuming we can just put it together?

APP: We have something, but it’s sketchy. I had intended to use :number and :date as a template to spell that out. That’s important b/c one of the remaining tasks is to take the design pieces for number and date and put them into registry.md. String has to be included too. Should be non-controversial.

EAO: Other things: #619, add warning about ‘*’ – I think APP, that’s on you?

APP: Uncontroversial, because it’s a note 

EAO: Related issue, #575, about the data model using namespaced and non-namespaced names. Do we add something like a nsOptionalString to a place where a name might be an identifier? Or keep the current behavior where the name fields encodes namespace.name?

APP: My tendency is to want to name identifiers “identifier”. So where a name is allowed to be naked, it can be name, but call an identifier name. What you’re asking is whether we split the namespace identifier from the name, and have two fields?

EAO: Yes

APP: STA had an opinion on that. 

APP: Identifier is the ABNF term, an optional namespace plus a name.

EAO: I think the changes this would affect are function annotation and option – currently the data model has name : string, so if we want to keep them separate, the least change would be to keep name: string and add an optional ns?: for namespace, if included. 

MIH: putting something in chat… 

APP: I don’t see why namespaces is an array, b/c there can only be one. If there’s a namespaced name that’s an identifier, you could treat it as an atomic unit. But the only dissonance for me is it’s called “name” here and “identifier” there, and “identifier” contains a name. foo:number is a different function from :number.

MED: It’s a different identifier

APP: Do we need to know that the namespace is there?

MIH: If you think it helps, we can also rename things “identifier”, but having a typedef, like identifier = string.

EAO: We can also opt not to do anything and keep the names and identifier in the data model.

APP: It’s easier to check.

EAO: I’d be happy to use id as a shorter version of it.

APP: I’d prefer to have more consistency in naming.

EAO: We’re coalescing on a single string field for this, we’re just bikeshedding on the name.

APP: Any objections to using name and keeping a note saying “sometimes, names can be identifiers”.

MIH: Let’s do name = identifier.

TIM: I’m just wondering if there’s reasons not to separate the name and namespace in the data model?

APP: Because you won’t use it as often but you’re right, it’s loss of fidelity. We need to figure it out later but would it break our data model’s stability guarantee?

Validating runtime types (408)

USA: I have a proposal to just drop this. I see there’s not a lot of clarity on how to do the validation. On the topic of regex, that is the most powerful way we allow the validation of literals. It’s not entirely platform- and programming-language-agnostic. But that’s just the beginning. We might be able to do strings, simple numbers, matching < / > etc., but I don’t feel like we’d be able to match the different variety of cases people come up with, and secondly, it’s not as important b/c if someone is implementing a custom function, then they’re doing it in an environment where they already have a much more powerful way to validate their arguments. Instead, educate the authors of these functions to validate the arguments within the functions. It also brings a layering problem, like the implementation tells the programmer what validation rules it supports, and then the programmer uses a custom function that uses some of these and all of that sort of makes everything complicated, but not for a huge benefit as I can see.

APP: If you look at the number and date things we just accepted, you’ll see how we’ve solved that. We solved it by saying the function accepts an implementation-defined type. Accepting implementation-defined types is fine, it’s platform- and PL-agnostic and solves the problem of types at that level. Your specific registry might specify a list of types, but that’s the registry author’s problem. What we have to solve is that if the value is passed as a literal, what literal is expected? We specify literal patterns that are accepted, and all others are not accepted. That’s how you can pass a value as a literal as opposed to as a type. A function could also just not accept any literals. But if you have a literal representation you need to specify what it is. Issues lag from the days when we might have had types

MIH: Regex won’t be used at runtime in any way, just for linters/etc. Some things can’t be parsed that way. But hardcoding literals in the placeholder is a pretty rare thing; mostly useful for numbers. The main reason is for user preferences. 

USA: We might be more aligned on this than anything, b/c in the issue it talks more about the runtime, where I’m more concerned about this. To be clear, I understand that it works for literals, but it only works for strings and then it’s not the ideal solution. This flavor of regexp is the most common, but not the only one. If we are getting into a design space where there’s not a whole lot of stuff we can do, we should just totally concede this ground to the function implementors. This way, they would have no doubts about the fact that they would have to validate. I hope they would still validate their inputs at runtime since you can’t always trust the implementation.

TIM: Just to clarify, you just mean a string and not a literal in terms of the spec.

EAO: We had this discussion already, I’ve pasted the notes but I don’t think there’s something to resolve here.

